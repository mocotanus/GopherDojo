package main

import "fmt"

func main() {

	// キャスト
	var f float64 = 10
	var n int = int(f)
	print("キャスト ")
	println(n)

	// ------------------------------------------------------------
	// 【TRY】組み込み型（数値）
	var sum int
	sum = 5 + 6 + 3
	avg := sum / 3 // avgには4が入っている
	// avg := float64(sum) / 3.0
	println(avg)

	// コンパイルエラー：constant 4.5 truncated to integer
	//4.5が整数じゃないため

	// 4.5の型を調べる
	fmt.Printf("%T\n", 4.5) // 4.5の型はfloat64

	// if avg > 4.5 {
	if float64(avg) > 4.5 {
		println("good")
	}

	// 型の違う値は計算できないらしい

	// ------------------------------------------------------------
	//【TRY】組み込み型（真偽値）
	var a, b, c bool
	if a && b || !c {
		println("true")
	} else {
		println("false")
	}

	// ------------------------------------------------------------
	// コンポジット型(構造体、配列、スライス、マップ)

	// 型リテラル
	// // int型のスライスの型リテラルを使った変数定義
	// var ns []int
	// // mapの型リテラルを使った変数定義
	// var m map[string]int

	// ------------------------------------------------------------
	// 構造体
	// var p struct {
	// 	name string
	// 	age  int
	// }

	// 構造体リテラルの例
	// p2 := struct {
	// 	name string
	// 	age  int
	// }{
	// 	name: "Gopher",
	// 	age:  10,
	// }

	// フィールドの参照
	p := struct {
		name string
		age  int
	}{name: "Gopher", age: 10}
	// フィールドにアクセスする例
	p.age++ // p.age = p.age + 1と同じ
	println(p.name, p.age)

	// ------------------------------------------------------------
	// 配列
	// 型と要素数がセット
	// var ns [5]int

	// 配列の初期化
	// // ゼロ値で初期化(配列を定義するだけだとこうなる)
	// var ns1 [5]int
	// // 配列リテラルで初期化(初期化と同時に値をセット)
	// var ns2 = [5]int{10, 20, 30, 40, 50}
	// // 要素数を値から推論(修正が楽になるかんじ？)
	// ns3 := [...]int{10, 20, 30, 40, 50}
	// // 5番目が50、10番目が100で他が0の要素数11の配列
	// ns4 := [...]int{5: 50, 10: 100}

	// 配列の操作
	ns := [...]int{10, 20, 30, 40, 50}
	// 要素にアクセス
	print("要素にアクセス ")
	println(ns[3]) // 添字は変数でもよい
	// 長さ
	print("長さ ")
	println(len(ns))
	// スライス演算
	print("スライス演算 ")     // なにこれ？
	fmt.Println(ns[1:2]) // 結果：[20]

	// ------------------------------------------------------------
	// スライス(配列の一部を切り出したもの)

	// スライスの初期化
	// // ゼロ値はnil(定義だけした場合)
	// var ns1 []int
	// // 長さと容量を指定して初期化(容量って？→配列の個数っぽい)
	// // 各要素はゼロ値で初期化される
	// ns1 = make([]int, 3, 10)
	// // スライスリテラルで初期化(配列を定義していなくても、いきなりスライスを作成する)
	// // 要素数は指定しなくてよい
	// // 自動で配列は作られる
	// var ns2 = []int{10, 20, 30, 40, 50}
	// // 5番目が50、10番目が100で他が0の要素数11のスライス
	// ns3 := []int{5: 50, 10: 100}

	// スライスの初期化
	// // ゼロ値はnil
	// var ns1 []int
	// // 長さと容量を指定して初期化
	// // 各要素はゼロ値で初期化される
	// ns1 = make([]int, 3, 10)
	// // スライスリテラルで初期化
	// // 要素数は指定しなくてよい
	// // 自動で配列は作られる
	// var ns2 = []int{10, 20, 30, 40, 50}
	// // 5番目が50、10番目が100で他が0の要素数11のスライス
	// ns3 := []int{5: 50, 10: 100}

	// スライスの操作
	ns4 := []int{10, 20, 30, 40, 50}
	// 要素にアクセス
	print("要素にアクセス ")
	println(ns4[3]) // 40
	// 長さ
	print("長さ ")
	println(len(ns4)) // 5
	// 要素の追加
	print("要素の追加 ")
	// 容量が足りない場合は背後の配列が再確保される
	ns4 = append(ns4, 60, 70) //
	// 容量
	print("容量")
	println(cap(ns4))

	// ------------------------------------------------------------
	// appendの挙動
	fmt.Print("配列の中身: ")
	a1 := []int{10, 20}
	// [10 20] 2
	fmt.Println(a1, cap(a1))

	// appendしたときに容量が足りない場合
	// 2倍の配列を作り直す
	b1 := append(a1, 30) // (1)
	a1[0] = 100          // (2)
	// [10 20 30] 4
	fmt.Println(b1, cap(b1))

	c1 := append(b1, 40) // (3)
	b1[1] = 200          // (4)
	// [10 200 30 40] 4
	fmt.Println(c1, cap(c1))

}
